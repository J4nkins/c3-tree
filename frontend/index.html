<!DOCTYPE html>
<html>
  <head>
    <title>C3Tree</title>
    <meta charset="utf-8" />

    <style type="text/css">
      html, body {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
      }
      .canvas-wrapper {
        margin: 0 auto;
      }
      #controls-wrapper {
        position: absolute;
        width: 200px;
      }
      .tooltip {
        position: absolute;
        pointer-events: none;
        background: #ffffff;
        border: 1px solid #f0f0f0;
        box-shadow: 3px 3px 7px 1px rgba(0,0,0,0.15);
        -webkit-box-shadow: 3px 3px 7px 1px rgba(0,0,0,0.15);
        -moz-box-shadow: 3px 3px 7px 1px rgba(0,0,0,0.15);
        -webkit-border-radius: 0.2em;border-radius: 0.2em;
      }
      .tooltip-title {
        font-weight: bold;
        font-size: 80%;
        color: #a0a0a0;
        margin-top: 20px;
      }
      .tooltip table {
        width: 100%;
        padding: 10px;
      }
      .tooltip table tr, .tooltip table td, .tooltip table p {
        padding: 0;
        margin: 0;
        border-spacing: 0;
      }
      .tooltip table td a {
        text-decoration: none;
        font-weight: bold;
        text-transform: lowercase;
        font-size: 80%;
      }
      .tooltip-close-button {
        position: absolute;
        right: 10px;
        top: 10px;
        font-size: 22px;
        font-family: arial;
        cursor: pointer;
      }
      .tooltip-bottom-note {
        color: #a0a0a0;
        font-size: 80%;
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    
    <div id="loader" style="position: absolute; left: 50%; top: 50%; width: 400px; height: 300px; margin: -150px 0 0 -200px;text-align: center">
      <span>Welcome!<br/>Now loading data from Google Sheet API...</span>
      <img src="/loading_bars.svg" alt="loading-bars"/>
    </div>


    <div id="tooltip-wrapper">
      <div id="hover-tooltip" class="tooltip" style="display:none">
        <div class="tooltip-close-button" style="display:none">x</div>
        <center>
          <div class="tooltip-title"></div>
        </center>
        <table class="table-main" cellspacing="15">
          <tbody class="tooltip-tbody"></tbody>
        </table>
        <center>
          <button type="button" class="button-publication-link">Go to publication</button>
        </center>
        <svg class="tooltip-collapsible-button" style="margin-left:25px; cursor:pointer" width="15px" height="15px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
          <path d="M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"
            fill="#202020"
            transform="translate(256,256) rotate(90) translate(-256,-256)"/>
        </svg>
        <table class="table-collapsed" cellspacing="15">
          <tbody class="tooltip-tbody"></tbody>
        </table>
        <center><div class="tooltip-bottom-note">Click on the leaf to stick.</div></center>
      </div>
    </div>

    <div id="controls-wrapper" style="display:none;">
      <center>
        <select id="viz-select" style="width:200px">
          <option value="0">Radial Tree</option>
          <option value="1">Connected Edges</option>
        </select>
        <select id="preset-select" style="margin-top:20px;display:none;width:200px">
        </select>
        <br/><br/>
        <input style="float:left;display:block" type="checkbox" id="checkbox-image" checked>
        <span style="float:left;display:block">Show center image</span>
        <div style="clear: both;"></div>
        <input style="float:left;display:block" type="checkbox" id="checkbox-leaf-titles" checked>
        <span style="float:left;display:block">Show leaf titles</span>
        <div style="clear: both;"></div>
        <input style="float:left;display:block" type="checkbox" id="checkbox-twist-circle" checked>
        <span style="float:left;display:block">Large twist circle</span>
        <div style="clear: both;"></div>
        <br/>
        <input style="float:left;display:block" type="checkbox" class="checkbox-status" id="checkbox-status-Published" checked>
        <span style="float:left;display:block">Status: Published</span>
        <div style="clear: both;"></div>
        <input style="float:left;display:block" type="checkbox" class="checkbox-status" id="checkbox-status-Accepted" checked>
        <span style="float:left;display:block">Status: Accepted</span>
        <div style="clear: both;"></div>
        <input style="float:left;display:block" type="checkbox" class="checkbox-status" id="checkbox-status-Submitted" checked>
        <span style="float:left;display:block">Status: Submitted</span>
        <div style="clear: both;"></div>
        <input style="float:left;display:block" type="checkbox" class="checkbox-status" id="checkbox-status-Manuscript" checked>
        <span style="float:left;display:block">Status: Manuscript</span>
        <div style="clear: both;"></div>
      </center>
    </div>

    <div class="canvas-wrapper">
      <svg id="d3-canvas" opacity="0.0"/>
    </div>

    <script src="/d3/dist/d3.min.js"></script>

    <script type="text/javascript">

      let checkboxesChecked = {
      };

      d3.selectAll("input[type='checkbox']").each(function() {
        checkboxesChecked[d3.select(this).attr("id")] = d3.select(this).property("checked");
        if(d3.select(this).attr("class") === "checkbox-status" && !checkboxesChecked[d3.select(this).attr("id")]) {
          d3.select(this).property("checked", true);
          checkboxesChecked[d3.select(this).attr("id")] = true;
        }
      });
      d3.select("#checkbox-image").on("change", (event) => {
        checkboxesChecked["checkbox-image"] = !checkboxesChecked["checkbox-image"];
        d3.select("#center-image").attr("opacity", checkboxesChecked["checkbox-image"] ? 1.0 : 0.0)
      });
      d3.select("#checkbox-twist-circle").on("change", (event) => {
        checkboxesChecked["checkbox-twist-circle"] = !checkboxesChecked["checkbox-twist-circle"];
        rerenderTree();
      });
      d3.select("#checkbox-leaf-titles").on("change", (event) => {
        checkboxesChecked["checkbox-leaf-titles"] = !checkboxesChecked["checkbox-leaf-titles"];
        rerenderTree();
      });
      d3.selectAll(".checkbox-status").on("change", function() {
        const checkboxId = d3.select(this).attr("id");
        checkboxesChecked[checkboxId] = !checkboxesChecked[checkboxId];
        const statusAffected = checkboxId.replace("checkbox-status-", "")
        root.leaves().forEach((d) => {
          if(d.data.props.status === statusAffected) {
            setTreeVisibility(d.data, checkboxesChecked[checkboxId]);
          }
        });
        rerenderTree();
      });

      const addLineBreaks = (text, maxWidth, dy, lineHeight) => {
        const y = text.attr("y");
        const words = text.text().split(/\s+/).reverse();

        let word;
        let line = [];
        let tspan = text
          .text(null)
          .append("tspan")
          .attr("x", 0)
          .attr("y", y)
          .attr("dy", `${dy}em`)
          .attr("data-initial-dy", dy);
        let lineCount = 1;

        while ((word = words.pop())) {
          line.push(word);
          tspan.text(line.join(" "));
          if (line.length > 1 && tspan.node() && tspan.node().getComputedTextLength() > maxWidth) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text
              .append("tspan")
              .attr("x", 0)
              .attr("y", y)
              .attr("dy", `${lineHeight}em`)
              .attr("data-initial-dy", lineHeight)
              .text(word);
            lineCount += 1;
          }
        }

        return lineCount;
      };

      let data;
      let root;
      let twist = 0;

      const getParentWidthDepth = (d, depth) => {
        let parent = d.parent;
        while(parent && parent.depth > depth)
          parent = parent.parent;
        return depth === parent?.depth ? parent : null;
      }

      let mode = d3.select("#viz-select").node().value === "0" ? "viz-select-0" : "viz-select-1";

      d3.select("#viz-select").on("change", (event) => {
        if(event.target.value === "0") {
          mode = "viz-select-0";
          d3.selectAll("#curves-wrapper-center").attr("opacity", 1.0);
          d3.selectAll("#curves-wrapper-leaves").attr("opacity", 0.0);
        } else {
          mode = "viz-select-1";
          d3.selectAll("#curves-wrapper-center").attr("opacity", 0.0);
          d3.selectAll("#curves-wrapper-leaves").attr("opacity", 1.0);
        }
        rerenderTree(false);
      });

      const initializePresetsDropdown = (presets) => {
        d3.select("#preset-select")
          .style("display", "block")
          .selectAll("option")
          .data(["No preset (all visible)", ...presets])
          .join("option")
          .attr("value", (d) => d)
          .text((d) => d);

        d3.select("#preset-select")
          .on("change", (event) => {
            const chosenPreset = event.target.value;
            root.descendants().forEach((d) => {
              d.data.visible = !d.data.presets.includes(chosenPreset) && d.depth > 0;
            })
            rerenderTree();
          });
      }

      

      const margin = {
        top: 90,
        right: 90,
        bottom: 90,
        left: 90,
      }
      const width  = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      const height = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
      let canvasWidth = width;
      let canvasHeight = height;
      if(width < height) {
        d3.select("#controls-wrapper").style("left", "50%").style("top", `${(height - width) / 2.0 - 20}px`).style("margin-left", "-100px");
        d3.selectAll(".canvas-wrapper").style("margin-top", `${(height - width) / 2.0}px`)
      } else {
        d3.select("#controls-wrapper").style("left", `${(width - height) / 2.0 - 220}px`).style("top", `35%`)
      }
      d3.select("#controls-wrapper").style("display", "block");
      d3.selectAll(".canvas-wrapper").style("width", `${canvasWidth}px`).style("height", `${canvasHeight}px`)

      const tooltipWidth = 800;
      d3.select("#hover-tooltip").style("width", `${tooltipWidth}px`).style("height", "auto")

      const radius = d3.min([canvasWidth - margin.left - margin.right, canvasHeight - margin.top - margin.bottom]) / 2 - 150;
      const outerRadius = radius + 90;

      const radialTreeLine = d3.linkRadial()
        .source((d) => ({
            x: d.source.x,
            y: d.source.y + (d.source.parent ? (d.source.parent.y - d.source.y) * 0.7 : 0),
        }))
        .target((d) => ({
            x: d.target.x,
            y: d.target.y + (d.target.parent && d.target.children ? (d.target.parent.y - d.target.y) * 0.7 : 0),
        }))
        .angle((d) => d.x)
        .radius((d) => d.y);
      const connectedEdgesLine = d3.lineRadial()
        .curve(d3.curveBundle.beta(0.9))
        .radius((d) => d.y)
        .angle((d) => d.x);
      const separation = (a, b) => {
        if((a.parent && !a.parent.data.visible) && (b.parent && !b.parent.data.visible))
          return 0.05;
        else if(!a.data.visible && !b.data.visible) 
          return a.parent?.parent === b.parent?.parent ? 0.2 : 2;
        else if(!a.data.visible || !b.data.visible)
          return a.parent?.parent === b.parent?.parent ? 0.5 : 1;
        else
          return a.parent == b.parent ? 1 : 2;
      };


      const calcTreeDepths = (d) => d.children?.length > 0 ? d.children.map(calcTreeDepths).flat() : d.depth;

      const setTreeVisibility = (d, visible) => {
        d.visible = visible;
        if(d.children?.length > 0) 
          d.children.map((child) => setTreeVisibility(child, visible));
      }

      const nodeOnClick = (d) => {
        setTreeVisibility(d.data, !d.data.visible);
        rerenderTree();
      }


      const rerenderTree = (animated = true) => {

        twist = twist > Math.PI * 2.0 ? twist - Math.PI * 2.0 : twist;
        twist = twist < 0 ? twist + Math.PI * 2.0 : twist;

        const treeFunction = d3.cluster().size([2 * Math.PI, radius]);
        treeFunction.separation(separation)(root);

        const animation = d3.transition().duration(animated ? 750 : 0).ease(d3.easeQuadOut);

        // curves from center to leaves
        //d3.selectAll(".center-to-leaf-path").remove();


        d3.select("#twist-circle")
          .attr("opacity", checkboxesChecked["checkbox-twist-circle"] ? 1.0 : 0.0)
          .style("pointer-events", checkboxesChecked["checkbox-twist-circle"] ? "visibleStroke" : "none")
        d3.selectAll("#twist-circle-small-g *")
          .attr("opacity", checkboxesChecked["checkbox-twist-circle"] ? 0.0 : 1.0)
          .style("pointer-events", checkboxesChecked["checkbox-twist-circle"] ? "none" : "visibleStroke")

        d3.select("#main-transform")
            .attr("transform", `translate(${canvasWidth / 2.0},${canvasHeight / 2.0})
              rotate(${(twist) * 180 / Math.PI})`);

        const curvesCenterUpdate = d3.select("#curves-wrapper-center")
          .selectAll(".center-to-leaf-path")
          .data(root.links())
          .call((update) => {
            update.transition(animation)
              .attr("d", radialTreeLine)
              .attr("stroke", (d) => d.target.data.color)
              .attr("stroke-width", 1.5)
              .attr("opacity", (d) => d.source.data.visible && d.target.data.visible ? 1.0 : 0.0)
          });

        d3.select("#curves-wrapper-leaves")
          .selectAll(".leaf-to-leaf-path")
          .data(root.leaves().flatMap((leaf) => {
            return root.leaves().filter(
              (d) => d.data.props.data_source === leaf.data.props.data_source && d !== leaf).map(
              (d) => [leaf, d]);
          }))
          .call((update) => {
            update.transition(animation).attr("d", ([i, o]) => connectedEdgesLine(i.path(o)))
              .attr("opacity", (d) => d[0].data.visible && d[1].data.visible ? 0.1 : 0.0);
          });

        d3.select("#outer-node-group-wrapper")
          .selectAll(".outer-node-group")
          .transition(animation)
          .attr("class", "outer-node-group")
          .attr("transform", (d) => `rotate(${d.x * 180 / Math.PI - 90}) translate(${radius + 130},0)`)
          .attr("opacity", (d) => d.data.visible ? 1 : 0)
            

        const nodeGroupUpdate = d3.selectAll(".node-group")
          .data(root.descendants())
          .call((update) => {
            update.transition(animation)
              .attr("transform", (d) => `rotate(${d.x * 180 / Math.PI - 90}) 
                translate(${d.y + (d.parent && d.children ? (d.parent.y - d.y) * 0.7 : 0)},0)`)

            update.selectAll(".node-text")
              .attr("x", (d) => {
                let angle = d.x + twist;
                angle = angle > Math.PI * 2.0 ? angle - Math.PI * 2.0 : angle < 0 ? angle + Math.PI * 2.0 : angle;
                return angle < Math.PI ? 12 : -12;
              })
              .attr("text-anchor", (d) => {
                let angle = d.x + twist;
                angle = angle > Math.PI * 2.0 ? angle - Math.PI * 2.0 : angle < 0 ? angle + Math.PI * 2.0 : angle;
                return angle < Math.PI ? "start" : "end";
              })
              .attr("transform", (d) => {
                let angle = d.x + twist;
                angle = angle > Math.PI * 2.0 ? angle - Math.PI * 2.0 : angle < 0 ? angle + Math.PI * 2.0 : angle;
                return `rotate(${angle >= Math.PI ? 180 : 0})`;
              })

            update.selectAll(".node-text").transition(animation)
              .attr("opacity", (d) => d.data.depth > 2 && (d.data.visible /*|| d.parent?.data.visible*/) && checkboxesChecked["checkbox-leaf-titles"] ? 1.0 : 0.0)

            update.selectAll(".text-leaf-interact-area")
              .style("pointer-events", (d) => d.data.visible ? "all" : "none");

            
            

          });

        d3.selectAll(".node-circle")
          .attr("opacity", (d) => mode === "viz-select-0" && (d.data.visible /*|| d.parent?.data.visible*/ || d.parent?.data.id === "r") ? 1.0 : 0.0);

        d3.select("#category-labels-wrapper")
          .selectAll(".category-labels")
          .transition(animation)
          .attr("transform", (d) => `rotate(${d.x * 180 / Math.PI - 90}) 
            translate(${radius + 200},0)
            rotate(${(-d.x - twist) * 180 / Math.PI + 90}) `)
          .attr("text-anchor", (d) => {
            let angle = d.x + twist;
            angle = angle > Math.PI * 2.0 ? angle - Math.PI * 2.0 : angle < 0 ? angle + Math.PI * 2.0 : angle;
            return angle < Math.PI ? "start" : "end"
          })
          .attr("dominant-baseline", "middle")
          .attr("font-size", "20px")
          .attr("font-weight", "bold")
          .attr("opacity", (d) => d.data.visible ? 1.0 : 0.0)
          .attr("fill", (d) => d.data.color)
      }





      const createCollapsableRadialTree = () => {

        root = d3.hierarchy(data);
        
        const treeFunction = d3.cluster().size([2 * Math.PI, radius]);
        treeFunction.separation(separation)(root);

        d3.select("body")
          .on("click", (event) => {
            if(!d3.select("#sticky-tooltip").empty()) d3.select("#sticky-tooltip").remove();
          })

        d3.select("#loader").style("display", "none");
        d3.select("#d3-canvas").selectAll("*").remove();
        const svg = d3.select("#d3-canvas")
          .attr("opacity", 1.0)
          .attr("viewBox", [0, 0, canvasWidth, canvasHeight])
          .attr("width", canvasWidth)
          .attr("height", canvasHeight)
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .append("g")
          .attr("id", "main-transform")
          //.attr("transform", `translate(${canvasWidth / 2.0},${canvasHeight / 2.0}) rotate(-70)`);
          .attr("transform", `translate(${canvasWidth / 2.0},${canvasHeight / 2.0})`);

        // center image
        const brainAspectRatio = 0.822;
        const brainSize = 0.65;
        d3.select("#d3-canvas")
          .append("image")
          .attr("id", "center-image")
          .attr("opacity", checkboxesChecked["checkbox-image"] ? 1.0 : 0.0)
          .attr("href", "/center_logo.png")
          .attr("width", radius * brainSize)
          .attr("height", radius * brainSize * brainAspectRatio)
          .style("pointer-events", "none")
          .attr("transform", `translate(
            ${width / 2.0 - radius * brainSize / 2.0},
            ${height / 2.0 - radius * brainSize / 2.0 * brainAspectRatio})`);


        // research questions text in the corners (currently only works with 4)
        svg.append("g")
          .attr("id", "category-labels-wrapper")
          .selectAll(".category-labels")
          .data(root.descendants().filter((d) => d.depth === 1))
          .join("text")
          .attr("class", (d) => "category-labels")
          .attr("transform", (d) => `rotate(${d.x * 180 / Math.PI - 90}) 
            translate(${radius + 100},0)
            rotate(${-d.x * 180 / Math.PI + 90}) `)
          /*.attr("transform", (d, i) => `translate(
            ${[0,3].includes(i) ? canvasWidth / 2.0 - radius : canvasWidth / 2.0 + radius},
            ${[0,1].includes(i) ? margin.top : canvasHeight - margin.bottom})`)*/
          .attr("text-anchor", (d) => d.x < Math.PI ? "start" : "end")
          .attr("dominant-baseline", "middle")
          .attr("font-size", "20px")
          .attr("font-weight", "bold")
          .attr("opacity", 1.0)
          .attr("fill", (d) => d.data.color)
          .text((d) => d.data.text)
          .each(function(d) {
            addLineBreaks(d3.select(this), canvasWidth / 2 - radius - 80, 0, 1.0)
          });

        // curves from center to leaves
        svg.append("g")
          .attr("id", "curves-wrapper-center")
          .attr("fill", "none")
          .attr("opacity", 0.0)
          .selectAll(".center-to-leaf-path")
          .data(root.links())
          .join("path")
            .attr("class", "center-to-leaf-path")
            .attr("d", radialTreeLine)
            .attr("stroke", (d) => d.target.data.color)
            .attr("stroke-width", 1.5)
            .attr("opacity", (d) => d.source.data.depth > 0 ? 1.0 : 0.0);

        // curves from leaf to leaf (connected edges)
        const leaves = root.leaves();
        svg.append("g")
          .attr("id", "curves-wrapper-leaves")
          .attr("fill", "none")
          .attr("opacity", 0.0)
          .selectAll("path")
          .data(leaves.flatMap((leaf) => {
            return leaves.filter(
              (d) => d.data.props.data_source === leaf.data.props.data_source && d !== leaf).map(
              (d) => [leaf, d]);
          }))
          .join("path")
            .attr("class", "leaf-to-leaf-path")
            .attr("data-connection-data-source", (d) => `${d[0].data.props.data_source}`)
            .attr("fill", "tansparent")
            .attr("stroke", "#d0d0d0")
            .attr("stroke-width", 1.0)
            .attr("opacity", 0.5)
            .attr("d", ([i, o]) => connectedEdgesLine(i.path(o)));


        const outerNodes = svg.append("g")
          .attr("id", "outer-node-group-wrapper")
          .selectAll(".outer-node-group")
          .data(root.descendants().filter((d) => d.children && d3.sum(d.children.map((child) => child.children !== undefined ? 1 : 0)) === 0))
          .join("g")
            .attr("class", "outer-node-group")
            .attr("transform", (d) => `rotate(${d.x * 180 / Math.PI - 90}) translate(${radius + 130},0)`)

        outerNodes.append("circle")
          .attr("fill", (d) => d.data.color)
          .attr("r", 10)
          .style("cursor", "pointer")

        // texts (leaves etc.)
        const node = svg.append("g")
          .attr("id", "node-group-wrapper")
          .selectAll(".node-group")
          .data(root.descendants())
          .join("g")
            .attr("class", "node-group")
            .attr("transform", (d) => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y + (d.parent && d.children ? (d.parent.y - d.y) * 0.7 : 0)},0)`);

        node.append("text")
          .attr("class", "node-text")
          .attr("id", (d) => `${d.data.id}-text`)
          .attr("dy", "0.32em")
          .attr("paint-order", "stroke")
          .attr("stroke", "white")
          .attr("stroke-width", 3)
          .attr("opacity", (d) => d.data.depth > 2 ? 1.0 : 0.0)
          .attr("fill", (d) => d.data.color)
          .attr("font-size", "10px")
          .style("pointer-events", "none")
          .text((d) => d.data.text)
          .each(function(d) {
            let textLength = d3.select(this).node().getComputedTextLength();
            let text = d.data.text;
            while(textLength > 70) {
              text = `${text.slice(0,-5)}...`;
              d3.select(this).text(text);
              textLength = d3.select(this).node().getComputedTextLength();
            }
          });
        node.filter((d) => !d.children).append("rect")
          .attr("class", "text-leaf-interact-area")
          .attr("fill", "transparent")
          .attr("opacity", 0.5)
          .attr("y", -10)
          .attr("width", 70)
          .attr("height", 30)
          .style("pointer-events", "all")
          .style("cursor", "pointer")


        d3.selectAll(".text-leaf-interact-area,.outer-node-group")
          .on("click", (event, d) => {
            event.stopPropagation();
            if(!d3.select("#sticky-tooltip").empty())
              d3.select("#sticky-tooltip").remove();

            const boundingRect = d3.select("#hover-tooltip.tooltip").node().getBoundingClientRect();
            const pointerPos = [event.pageX, event.pageY];
            const left = event.pageX + tooltipWidth >= width - 20 ? event.pageX - tooltipWidth - 10 : event.pageX + 10;
            const top = event.pageY + boundingRect.height >= height - 20 ? event.pageY - boundingRect.height - 10 : event.pageY + 10;
              
            const stickyTooltip = d3.select("#hover-tooltip.tooltip").clone(true)
              .attr("id", "sticky-tooltip")
              .style("display", "block")
              .style("left", `${left}px`)
              .style("top", `${top}px`)
              .style("pointer-events", "all")
              .style("cursor", "move")
              .on("mousedown", (event) => {
                event.stopPropagation();
                event.preventDefault();
                let startPointerPos = [event.pageX, event.pageY];
                let startPos = [
                  parseInt(d3.select("#sticky-tooltip").style("left")),
                  parseInt(d3.select("#sticky-tooltip").style("top"))
                ];
                const boundingRect = d3.select("#sticky-tooltip").node().getBoundingClientRect();
                const tooltipHeight = boundingRect.height;
                d3.select("body")
                  .on("mousemove.dragTooltip", (event) => {
                    let pointerPos = [event.pageX, event.pageY];
                    let deltaX = pointerPos[0] - startPointerPos[0];
                    let deltaY = pointerPos[1] - startPointerPos[1];
                    if(startPos[0] + deltaX > width - tooltipWidth) {
                      deltaX = (width - tooltipWidth) - startPos[0];
                    } else if(startPos[0] + deltaX < 0) {
                      deltaX = - startPos[0];
                    }
                    if(startPos[1] + deltaY > height - tooltipHeight) {
                      deltaY = (height - tooltipHeight) - startPos[1];
                    } else if(startPos[1] + deltaY < 0) {
                      deltaY = - startPos[1];
                    }

                    d3.select("#sticky-tooltip")
                      .style("left", `${startPos[0] + deltaX}px`)
                      .style("top", `${startPos[1] + deltaY}px`)
                  })
                  .on("mouseup.dragTooltip,mouseleave.dragTooltip", (event) => {
                    d3.select("body")
                      .on("mousemove.dragTooltip", null)
                      .on("mouseup.dragTooltip,mouseleave.dragTooltip", null);
                  });
              })
              .on("click", (event) => {
                event.stopPropagation();
                event.preventDefault();
              });
            d3.select("#hover-tooltip.tooltip").style("display", "none")
            stickyTooltip.style("pointer-events", "all");
            stickyTooltip.select(".tooltip-close-button")
              .style("display", "block")
              .on("click", () => d3.select("#sticky-tooltip").remove());
            stickyTooltip.select(".tooltip-bottom-note").remove();

            let collapsed = true;
            d3.select("#sticky-tooltip .tooltip-collapsible-button").on("click", (event) => {
              event.stopPropagation();
              if(collapsed) {
                d3.select("#sticky-tooltip .tooltip-collapsible-button path").transition("rotate").duration(200).ease(d3.easeQuadOut)
                  .attr("transform", "translate(256,256) rotate(180) translate(-256,-256)");
                d3.select("#sticky-tooltip .table-collapsed .tooltip-tbody").style("display", null);

                const boundingRect = d3.select("#sticky-tooltip.tooltip").node().getBoundingClientRect();
                const top = boundingRect.top + boundingRect.height > height ? height - boundingRect.height : boundingRect.top;
                d3.select("#sticky-tooltip.tooltip")
                  .style("top", `${top}px`);

              } else {
                d3.select("#sticky-tooltip .tooltip-collapsible-button path").transition("rotate").duration(200).ease(d3.easeQuadOut)
                  .attr("transform", "translate(256,256) rotate(90) translate(-256,-256)");
                d3.select("#sticky-tooltip .table-collapsed .tooltip-tbody").style("display", "none");
              }

              collapsed = !collapsed;
            });

            d3.select("#sticky-tooltip .button-publication-link")
              .on("click", (event) => {
                event.stopPropagation();
                window.open(d.data.props.publication_link);
              })
          
          })
          .on("mouseover", (event, d) => {

            const pointerPos = [event.pageX, event.pageY];
            const topic = getParentWidthDepth(d, 1);
            d3.select("#hover-tooltip .tooltip-title")
              //.text(d.data.text)
              .text(`TOPIC: ${topic.data.text}`);

            d3.select("#hover-tooltip .table-main .tooltip-tbody").selectAll("*").remove();
            const topicRow = d3.select("#hover-tooltip .table-main .tooltip-tbody").append("tr");
            /*topicRow.append("td").style("width", `${tooltipWidth * 0.2}px`)
              .append("p")
              .style("font-weight", "bold")
              .text("")*/
            topicRow.append("td").attr("colspan", 2).style("text-align", "center")
              .append("p")
              .style("font-weight", "bold")
              .text(d.data.text);

            /*const researchQuestion = getParentWidthDepth(d, 2);
            const researchQuestionRow = d3.select("#hover-tooltip .tooltip-tbody").append("tr");
            researchQuestionRow.append("td").style("width", `${tooltipWidth * 0.2}px`)
              .append("p")
              .style("font-weight", "bold")
              .text("Research Question")
            researchQuestionRow.append("td").append("p").text(researchQuestion.data.text);
            const subquestion = getParentWidthDepth(d, 3);
            if(subquestion) {
              const subquestionRow = d3.select("#hover-tooltip .tooltip-tbody").append("tr");
              subquestionRow.append("td").style("width", `${tooltipWidth * 0.2}px`)
                .append("p")
                .style("font-weight", "bold")
                .text("Subquestion")
              subquestionRow.append("td").append("p").text(subquestion.data.text);
            }*/
            

            Object.entries(d.data.props.info_main).forEach(([key, value]) => {
              if(value && value !== "") {
                const mainInfoRow = d3.select("#hover-tooltip .table-main .tooltip-tbody").append("tr");
                mainInfoRow.append("td").style("width", `${tooltipWidth * 0.2}px`)
                  .append("p")
                  .style("font-weight", "bold")
                  .text(key)
                mainInfoRow.append("td")
                  .append("p")
                  .text(value);
              }
            });

            if(d.data.props.publication_link)
              d3.select("#hover-tooltip .button-publication-link").style("display", null).style("pointer-events", "all");
            else 
              d3.select("#hover-tooltip .button-publication-link").style("pointer-events", "none").style("display", "none");

            d3.select("#hover-tooltip .table-collapsed .tooltip-tbody").style("display", "none").selectAll("*").remove();
            let collapsibleInfo = false;
            Object.entries(d.data.props.info_collapsed).forEach(([key, value]) => {
              if(value && value !== "") {
                collapsibleInfo = true;
                const collapsedInfoRow = d3.select("#hover-tooltip .table-collapsed .tooltip-tbody").append("tr");
                collapsedInfoRow.append("td").style("width", `${tooltipWidth * 0.2}px`)
                  .append("p")
                  .style("font-weight", "bold")
                  .text(key)
                collapsedInfoRow.append("td")
                  .append("p")
                  .text(value);
              }
            });
            if(!collapsibleInfo)
              d3.select("#hover-tooltip .tooltip-collapsible-button").style("display", "none").style("pointer-events", "none");
            else
              d3.select("#hover-tooltip .tooltip-collapsible-button").style("display", "block").style("pointer-events", "all");

            d3.select(`#${d.data.id}-text`).style("font-weight", "bold");
            d3.selectAll(`path[data-connection-data-source="${d.data.props.data_source}"]`)
              .attr("stroke", "#2652F4")
              .raise();
          })
          .on("mousemove", (event, d) => {
            //if(d3.select("#sticky-tooltip").empty()) {
              const boundingRect = d3.select("#hover-tooltip.tooltip").node().getBoundingClientRect();
              const pointerPos = [event.pageX, event.pageY];
              
              
              if(mode === "viz-select-0") {
                const left = event.pageX + tooltipWidth >= width - 20 ? event.pageX - tooltipWidth - 10 : event.pageX + 10;
                const top = event.pageY + boundingRect.height >= height - 20 ? event.pageY - boundingRect.height - 10 : event.pageY + 10;
                d3.select("#hover-tooltip.tooltip")
                  .style("left", `${left}px`)
                  .style("top", `${top}px`)
                  .style("display", "block")
                  .raise();
              } else {
                let left = event.pageX + 10;
                const top = event.pageY + 10;
                const xOffset = pointerPos[0] < width / 2.0 
                  ? (radius - pointerPos[0]) - tooltipWidth 
                  : pointerPos[0] - radius;
                const y = (top - height / 2.0) / (outerRadius);
                let x = Math.sqrt(1 - Math.pow(y, 2)) * outerRadius;
                if(pointerPos[0] < width / 2.0)
                  left = x * -1.0 + width / 2.0 - tooltipWidth;
                else
                  left = x + width / 2.0;
                
                //console.log(x);
                d3.select("#hover-tooltip.tooltip")
                  //.style("left", `${pointerPos[0] + xOffset + 10}px`)
                  .style("left", `${left}px`)
                  .style("top", `${pointerPos[1] + 10}px`)
                  .style("display", "block")
                  .raise();
              }

            //}
          })
          .on("mouseleave", (event, d) => {
            d3.select("#hover-tooltip.tooltip").style("display", "none");
            d3.select(`#${d.data.id}-text`).style("font-weight", null);
            d3.selectAll(`path[data-connection-data-source="${d.data.props.data_source}"]`)
              .attr("stroke", "#d0d0d0");
          });

        // leaf nodes
        node.append("circle")
          .attr("class", "node-circle")
          .attr("fill", (d) => d.data.color)
          .attr("r", (d) => d.data.props.status === "Accepted" || d.data.props.status === "Published" ? 4 : d.data.props.status === "Manuscript" ? 0 : 2)
          //.attr("opacity", (d) => d.children ? 0.0 : 1.0)
          .attr("transform", "translate(4,0)")
          .attr("opacity", (d) => d.depth === 0 ? 0.0 : 1.0);

        node.filter((d) => d.data.props.status).append("circle")
          .attr("class", "node-circle")
          .attr("fill", "transparent")
          .attr("stroke", (d) => d.data.color)
          .attr("stroke-width", 2)
          //.attr("opacity", (d) => d.children ? 0.0 : 1.0)
          .attr("opacity", (d) => d.depth === 0 ? 0.0 : 1.0)
          .attr("transform", "translate(4,0)")
          .attr("r", (d) => 4);

        node.filter((d) => d.depth !== 0 && d.children).append("circle")
          .attr("class", "node-interact-area")
          .attr("fill", "transparent")
          .attr("opacity", 0.0)
          .attr("r", 8)
          .style("pointer-events", "all")
          .style("cursor", "pointer")
          .on("click", (event, d) => nodeOnClick(d));

        if(d3.select("#viz-select").node().value === "0") {
          d3.selectAll("#curves-wrapper-center").attr("opacity", 1.0);
          d3.selectAll("#curves-wrapper-leaves").attr("opacity", 0.0);
        } else {
          d3.selectAll("#curves-wrapper-center").attr("opacity", 0.0);
          d3.selectAll("#curves-wrapper-leaves").attr("opacity", 1.0);
        }

        svg.append("circle")
          .attr("id", "twist-circle")
          .attr("r", outerRadius)
          .attr("fill", "none")
          .attr("stroke", "#e0e0e0")
          .attr("stroke-width", 10)
          .style("pointer-events", "visibleStroke")
          .style("cursor", "grab")
          .on("mousedown.twistCircle", (event) => {
            const startX = canvasWidth / 2.0 - event.clientX;
            const startY = canvasHeight / 2.0 - event.clientY;
            let lastAngle = Math.atan2(startX, startY);

            d3.select("body")
              .on("mousemove.twistCircle", (event) => {
                const x = canvasWidth / 2.0 - event.clientX;
                const y = canvasHeight / 2.0 - event.clientY;
                const angle = Math.atan2(x, y);

                const deltaAngle = lastAngle - angle;
                twist += deltaAngle;
                lastAngle = angle;

                rerenderTree(false);
              })
              .on("mouseleave.twistCircle,mouseup.twistCircle", (event) => {
                d3.select("body")
                  .on("mousemove.twistCircle", null)
                  .on("mouseleave.twistCircle", null)
                  .on("mouseup.twistCircle", null);
              })
              .on("mouseup", (event) => {
                d3.select("body")
                  .on("mousemove.twistCircle", null)
                  .on("mouseleave.twistCircle", null)
                  .on("mouseup.twistCircle", null);
              });
          });

        const twistCircleSmallX = canvasWidth / 2.0 + outerRadius;
        const twistCircleSmallY = canvasHeight / 2.0 + outerRadius;
        const twistCircleSmall = d3.select("#d3-canvas").append("g").attr("id", "twist-circle-small-g")
        twistCircleSmall.append("polygon")
          .attr("id", "twist-circle-small-triangle")
          .attr("points", "50 15, 100 100, 0 100")
          .attr("fill", "transparent")
          .attr("fill", "none")
          .attr("stroke", "#e0e0e0")
          .attr("stroke-width", 10)
          .attr("transform", `
            translate(${twistCircleSmallX},${twistCircleSmallY})
            scale(0.7,0.7) translate(${- 50},${- 15 - 85 / 2.0 - 11})`);
        twistCircleSmall.append("circle")
          .attr("id", "twist-circle-small")
          .attr("transform", `translate(${twistCircleSmallX},${twistCircleSmallY})`)
          .attr("r", 50)
          .attr("fill", "none")
          .attr("stroke", "#e0e0e0")
          .attr("stroke-width", 10)
          .style("pointer-events", "visibleStroke")
          .style("cursor", "grab")
          .on("mousedown.twistCircle", (event) => {
            const startX = twistCircleSmallX - event.clientX;
            const startY = twistCircleSmallY - event.clientY;
            let lastAngle = Math.atan2(startX, startY);

            d3.select("body")
              .on("mousemove.twistCircle", (event) => {
                const x = twistCircleSmallX - event.clientX;
                const y = twistCircleSmallY - event.clientY;
                const angle = Math.atan2(x, y);

                const deltaAngle = lastAngle - angle;
                twist += deltaAngle;
                lastAngle = angle;

                twistCircleSmall.attr("transform", `translate(${twistCircleSmallX},${twistCircleSmallY}) rotate(${twist * 180 / Math.PI}) translate(${-twistCircleSmallX},${-twistCircleSmallY})`)

                rerenderTree(false);
              })
              .on("mouseleave.twistCircle,mouseup.twistCircle", (event) => {
                d3.select("body")
                  .on("mousemove.twistCircle", null)
                  .on("mouseleave.twistCircle", null)
                  .on("mouseup.twistCircle", null);
              })
              .on("mouseup", (event) => {
                d3.select("body")
                  .on("mousemove.twistCircle", null)
                  .on("mouseleave.twistCircle", null)
                  .on("mouseup.twistCircle", null);
              });
          });

        rerenderTree(false);
      }

    </script>

    <script type="text/javascript">

      const colors = ["#8C88BA", "#BF84AE", "#DB95AC", "#FBB9A6", "#F6A294", "#B0DBEA", "#B3E5BE", "#CFC69D"];

      const buildHierarchy = ((parentLevel, data, presetsAvailable, presetsParent, depth) => {
        data.filter((d) => d.parent === parentLevel.text).forEach((d) => {

          const level = {
            "id": `${parentLevel.id}${parentLevel.children.length}`,
            "text": d.text,
            "color": depth === 1
              ? (parentLevel.children.length < colors.length ? colors[parentLevel.children.length] : "#808080")
              : parentLevel.color,
            "depth": depth,
            "visible": true,
            "props": {
              "publication_link": d.publication_link,
              "data_source": d.data_source,
              "status": d.Status,
              "info_main": {},
              "info_collapsed": {
                "Status": d.Status,
              },
            },
            "presets": [...presetsParent, ...presetsAvailable.filter((preset) => !presetsParent.includes(preset) && d[`[PRESET]${preset}`] === "x")],
            "children": [],
          };

          Object.keys(d).filter((key) => key.indexOf("[INFO_MAIN]") !== -1).forEach((key) => {
            level.props.info_main[key.replace("[INFO_MAIN]", "")] = d[key];
          });
          Object.keys(d).filter((key) => key.indexOf("[INFO_COLLAPSED]") !== -1).forEach((key) => {
            level.props.info_collapsed[key.replace("[INFO_COLLAPSED]", "")] = d[key];
          });

          parentLevel.children.push(level);
          buildHierarchy(level, data, presetsAvailable, level.presets, depth + 1);
        });
      });

      const parseSheetData = ((data, presets) => {
        
        const hierarchyRootLevel = {
          "id": "r",
          "text": "ROOT",
          "color": "#202020",
          "depth": 0,
          "visible": false,
          "props": {},
          "presets": [],
          "children": [],
        };

        buildHierarchy(hierarchyRootLevel, data, presets, [], 1);

        return hierarchyRootLevel;
      });

      const parseNCSAndLHWData = (responseData, header) => {
        rawData = [];
        const themesAdded = [];
        let theme = "";
        let subThemesAdded = [];
        responseData.forEach((row) => {
          
          // new theme
          if(row[0] !== undefined && row[0] !== "" && !themesAdded.includes(row[0])) {
            theme = row[0];
            rawData.push({
              "text": theme,
              "parent": "ROOT",
            });
            themesAdded.push(theme);
            subThemesAdded = [];
          }

          // new subtheme
          if(row[1] !== undefined && row[1] !== "" && !subThemesAdded.includes(row[1])) {
            let subTheme = row[1];
            rawData.push({
              "text": subTheme,
              "parent": theme,
            });
            subThemesAdded.push(subTheme);
          }

          const d = {
            "text": row[2],
            "parent": row[1],
          };
          header.slice(2).forEach((column, i) => {
            d[column] = row[i + 2]
          });
          rawData.push(d);
        });

        return rawData;
      };

      const parseDefaultData = (responseData, header) => {
        const rawData = responseData.map((row) => {
          const d = {};
          header.forEach((column, i) => {
            d[column] = row[i]
          });
          return d;
        });

        return rawData;
      };

      window.addEventListener("load", (event) => {
        
        console.log("sending data request");
        
        var xhr = new XMLHttpRequest();
        xhr.open("POST", "/fetch_c3tree_data_from_google_sheet", true);
        xhr.send(null);
        xhr.onload = () => {

          if(xhr.readyState === 4) {
            if(xhr.status === 200) {
              const response = JSON.parse(xhr.responseText);
              const header = response.data[0];
              const presets = header.filter((column) => column.includes("[PRESET]")).map((column) => column.replace("[PRESET]", ""));
              let researchTheme = "";
              const rawData = parseNCSAndLHWData(response.data.slice(1), header);
              data = parseSheetData(rawData, presets);
              createCollapsableRadialTree();
              initializePresetsDropdown(presets);
            } else {

            }
          }
        }

        xhr.onerror = (err) => {
          console.warn(err);
        }
        
      });

    </script>


  </body>
</html>