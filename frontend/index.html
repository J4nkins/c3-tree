<!DOCTYPE html>
<html>
  <head>
    <title>C3Tree</title>
    <meta charset="utf-8" />

    <style type="text/css">
      html, body {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    
    <div id="loader" style="position: absolute; left: 50%; top: 50%; width: 400px; height: 300px; margin: -150px 0 0 -200px;text-align: center">
      <span>Welcome!<br/>Now loading data from Google Sheet API...</span>
      <img src="/loading_bars.svg" alt="loading-bars"/>
    </div>

    <br/><br/>
    <center>
      <select id="viz-select">
        <option value="0">Radial Tree</option>
        <option value="1">Connected Edges</option>
      </select>
    </center>

    <svg id="d3-canvas" opacity="0.0"/>

    <script src="/d3/dist/d3.min.js"></script>

    <script type="text/javascript">

      d3.select("#viz-select").on("change", (event) => {
        if(event.target.value === "0") {
          d3.selectAll(".curves-wrapper-center").attr("opacity", 1.0);
          d3.selectAll(".curves-wrapper-leaves").attr("opacity", 0.0);
        } else {
          d3.selectAll(".curves-wrapper-center").attr("opacity", 0.0);
          d3.selectAll(".curves-wrapper-leaves").attr("opacity", 1.0);
        }
      });

      const createCollapsableRadialTree = (data) => {

        console.log(data);

        const treeFunction = d3.cluster;
        const separation = (a, b) => a.parent == b.parent ? 1 : 2;

        const margin = {
          top: 60,
          right: 60,
          bottom: 60,
          left: 60,
        }
        const width  = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        const height = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight) - 60;
        const radius = d3.min([width - margin.left - margin.right, height - margin.top - margin.bottom]) / 2 - 50;
        
        const root = d3.hierarchy(data);

        console.log(root);
        console.log(root.leaves());
        
        treeFunction().size([2 * Math.PI, radius]).separation(separation)(root);

        d3.select("#loader").style("display", "none");
        d3.select("#d3-canvas").selectAll("*").remove();
        const svg = d3.select("#d3-canvas")
          .attr("opacity", 1.0)
          .attr("viewBox", [0, 0, width, height])
          .attr("width", width)
          .attr("height", height)
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .append("g")
          .attr("transform", `translate(${width / 2.0},${height / 2.0}) rotate(-70)`);

        // center image
        const brainAspectRatio = 0.822;
        const brainSize = 0.65;
        d3.select("#d3-canvas")
          .append("image")
          .attr("opacity", 0.0)
          .attr("href", "/brain.png")
          .attr("width", radius * brainSize)
          .attr("height", radius * brainSize * brainAspectRatio)
          .attr("transform", `translate(
            ${width / 2.0 - radius * brainSize / 2.0},
            ${height / 2.0 - radius * brainSize / 2.0 * brainAspectRatio})`);


        // research questions text in the corners (currently only works with 4)
        d3.select("#d3-canvas").append("g")
          .selectAll("text")
          .data(data.children)
          .join("text")
          .attr("class", "category-labels")
          .attr("transform", (d, i) => `translate(
            ${[0,3].includes(i) ? width / 2.0 - radius : width / 2.0 + radius},
            ${[0,1].includes(i) ? margin.top : height - margin.bottom})`)
          .attr("text-anchor", (d, i) => [0,3].includes(i) ? "middle" : "middle")
          .attr("dominant-baseline", "middle")
          .attr("font-size", "20px")
          .attr("font-weight", "bold")
          .attr("fill", (d) => d.color)
          .text((d) => d.text)

        // curves from center to leaves
        svg.append("g")
          .attr("class", "curves-wrapper-center")
          .attr("fill", "none")
          .attr("opacity", 0.0)
          .selectAll("path")
          .data(root.links())
          .join("path")
            .attr("d", d3.linkRadial().angle((d) => d.x).radius((d) => d.y))
            .attr("stroke", (d) => d.target.data.color)
            .attr("stroke-width", 1.5)
            .attr("opacity", (d) => d.source.data.depth > 0 ? 1.0 : 0.0);

        // curves from leaf to leaf (connected edges)
        const radialLine = d3.lineRadial().curve(d3.curveBundle.beta(0.9)).radius((d) => d.y).angle((d) => d.x);
        const leaves = root.leaves();
        svg.append("g")
          .attr("class", "curves-wrapper-leaves")
          .attr("fill", "none")
          .attr("opacity", 0.0)
          .selectAll("path")
          .data(leaves.flatMap((leaf) => {
            return leaves.filter(
              (d) => d.data.props.data_source === leaf.data.props.data_source && d !== leaf).map(
              (d) => [leaf, d]);
          }))
          .join("path")
            .attr("data-connection-data-source", (d) => `${d[0].data.props.data_source}`)
            .attr("fill", "tansparent")
            .attr("stroke", "#d0d0d0")
            .attr("stroke-width", 1.0)
            .attr("opacity", 0.5)
            .attr("d", ([i, o]) => radialLine(i.path(o)));

        // texts (leaves etc.)
        const node = svg.append("g")
          .selectAll("g")
          .data(root.descendants())
          .join("g")
            .attr("transform", (d) => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y},0)`);

        node.append("text")
          .attr("id", (d) => `${d.data.id}-text`)
          .attr("transform", (d) => `rotate(${d.x >= Math.PI ? 180 : 0})`)
          .attr("dy", "0.32em")
          .attr("x", (d) => d.x < Math.PI === !d.children ? 6 : -6)
          .attr("text-anchor", (d) => d.x < Math.PI === !d.children ? "start" : "end")
          .attr("paint-order", "stroke")
          .attr("stroke", "white")
          .attr("stroke-width", 3)
          .attr("opacity", (d) => d.data.depth > 2 ? 1.0 : 0.0)
          .attr("fill", (d) => d.data.color)
          .attr("font-size", "10px")
          .style("pointer-events", "none")
          .text((d) => d.data.text);
        node.append("rect")
          .attr("class", "text-leaf-interact-area")
          .attr("fill", "transparent")
          .attr("opacity", 0.5)
          .attr("y", -10)
          .attr("width", 100)
          .attr("height", 20)
          .style("pointer-events", "all")
          .style("cursor", "pointer")
          .on("mouseover", (event, d) => {
            d3.select(`#${d.data.id}-text`).style("font-weight", "bold");
            d3.selectAll(`path[data-connection-data-source="${d.data.props.data_source}"]`)
              .attr("stroke", "#86A2F4")
              .raise();
          })
          .on("mouseleave", (event, d) => {
            d3.select(`#${d.data.id}-text`).style("font-weight", null);
            d3.selectAll(`path[data-connection-data-source="${d.data.props.data_source}"]`)
              .attr("stroke", "#d0d0d0");
          });
        // leaf nodes
        node.append("circle")
          .attr("fill", (d) => d.data.color)
          .attr("opacity", (d) => d.children ? 0.0 : 1.0)
          .attr("r", 3);

        // TODO: Replace with proper tooltip

        const titleFunction = (d, n) => `${n.ancestors().reverse().map((d) => d.data.text).join(".")}`;
        node.append("title").text((d) => titleFunction(d.data, d));

        if(d3.select("#viz-select").node().value === "0") {
          d3.selectAll(".curves-wrapper-center").attr("opacity", 1.0);
          d3.selectAll(".curves-wrapper-leaves").attr("opacity", 0.0);
        } else {
          d3.selectAll(".curves-wrapper-center").attr("opacity", 0.0);
          d3.selectAll(".curves-wrapper-leaves").attr("opacity", 1.0);
        }
      }

    </script>

    <script type="text/javascript">

      const colors = ["#8C88BA", "#BF84AE", "#DB95AC", "#FBB9A6", "#F6A294"];

      const buildHierarchy = ((parentLevel, data, depth) => {
        data.filter((d) => d.parent === parentLevel.text).forEach((d) => {

          const level = {
            "id": `${parentLevel.id}${parentLevel.children.length}`,
            "text": d.text,
            "color": depth === 1
              ? (parentLevel.children.length < colors.length ? colors[parentLevel.children.length] : "#808080")
              : parentLevel.color,
            "depth": depth,
            "props": {
              "link": d.link,
              "data_source": d.data_source,
            },
            "children": [],
          };

          parentLevel.children.push(level);
          buildHierarchy(level, data, depth + 1);
        });
      });

      const parseSheetData = ((data) => {
        
        const hierarchyRootLevel = {
          "id": "r",
          "text": "ROOT",
          "color": "#202020",
          "depth": 0,
          "props": {},
          "children": [],
        };

        buildHierarchy(hierarchyRootLevel, data, 1);

        console.log(hierarchyRootLevel);

        return hierarchyRootLevel;
      });

      window.addEventListener("load", (event) => {
        
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open("POST", "/fetch_c3tree_data_from_google_sheet", false);
        xmlHttp.send(null);
        const response = JSON.parse(xmlHttp.responseText);

        const hierarchyRootLevel = parseSheetData(response.data);

        createCollapsableRadialTree(hierarchyRootLevel);
      });

    </script>


  </body>
</html>